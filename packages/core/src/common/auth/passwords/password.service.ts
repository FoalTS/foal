import { pbkdf2, randomBytes, timingSafeEqual } from 'crypto';
import { promisify } from 'util';
import { decomposePbkdf2PasswordHash } from './utils';

export const PASSWORD_ITERATIONS = 600000;

/**
 * Options for password verification.
 *
 * @export
 */
export interface VerifyPasswordOptions {
  /**
   * Callback function called with a new hash when the password security needs to be upgraded.
   */
  onPasswordUpgrade?: (newHash: string) => Promise<void> | void;
}

/**
 * Service for password hashing and verification.
 *
 * @export
 */
export class PasswordService {
  /**
   * Hash a password using the PBKDF2 algorithm.
   *
   * Configured to use PBKDF2 + HMAC + SHA256.
   * The result is a 64 byte binary string.
   *
   * The random salt is 16 bytes long.
   * The number of iterations is 600,000.
   * The length key is 32 bytes long.
   *
   * @param {string} plainTextPassword - The password to hash.
   * @returns {Promise<string>} The derived key with the algorithm name, the number of iterations and the salt.
   */
  async hashPassword(plainTextPassword: string): Promise<string> {
    const saltBuffer = await promisify(randomBytes)(16);
    const iterations = PASSWORD_ITERATIONS;
    const keylen = 32;
    const digest = 'sha256';
    const derivedKeyBuffer = await promisify(pbkdf2)(plainTextPassword, saltBuffer, iterations, keylen, digest);

    const salt = saltBuffer.toString('base64');
    const derivedKey = derivedKeyBuffer.toString('base64');
    return `pbkdf2_${digest}$${iterations}$${salt}$${derivedKey}`;
  }

  /**
   * Compare a plain text password and a hash to see if they match.
   *
   * @param {string} plainTextPassword - The password in clear text.
   * @param {string} passwordHash - The password hash generated by the `hashPassword` method.
   * @param {VerifyPasswordOptions} [options] - Optional configuration object.
   * @returns {Promise<boolean>} True if the hash and the password match. False otherwise.
   */
  async verifyPassword(
    plainTextPassword: string,
    passwordHash: string,
    options?: VerifyPasswordOptions
  ): Promise<boolean> {
    const { digestAlgorithm, iterations, salt, derivedKey, keyLength } = decomposePbkdf2PasswordHash(passwordHash);

    const password = await promisify(pbkdf2)(
      plainTextPassword,
      salt,
      iterations,
      keyLength,
      digestAlgorithm
    );
    const isValid = timingSafeEqual(password, derivedKey);

    if (isValid && this.passwordHashNeedsToBeRefreshed(passwordHash) && options?.onPasswordUpgrade) {
      const newHash = await this.hashPassword(plainTextPassword);
      await options.onPasswordUpgrade(newHash);
    }

    return isValid;
  }

  /**
   * Check if a password hash needs to be refreshed.
   *
   * @param {string} passwordHash - The password hash to check.
   * @returns {boolean} True if the password hash needs to be refreshed. False otherwise.
   */
  passwordHashNeedsToBeRefreshed(passwordHash: string): boolean {
    const { iterations } = decomposePbkdf2PasswordHash(passwordHash);
    return iterations < PASSWORD_ITERATIONS;
  }
}

