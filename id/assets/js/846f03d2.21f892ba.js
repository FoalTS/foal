"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3262],{97841:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=n(74848),s=n(28453);const i={title:"Single Page Applications (SPA)",sidebar_label:"Single Page Applications"},o=void 0,a={id:"frontend/single-page-applications",title:"Single Page Applications (SPA)",description:"Single-Page Applications are Web Applications that are loaded once upon the first request(s) to the backend. After retreiving all the necessary code from the server, the current page is rendered and updated directly in the browser without asking the server to render new pages. During its lifecycle, the application usually communicates with the server by making API calls to fetch, create, update or delete data. This is a common pattern used when creating a new application with Angular, React or Vue.",source:"@site/i18n/id/docusaurus-plugin-content-docs/version-3.x/frontend/single-page-applications.md",sourceDirName:"frontend",slug:"/frontend/single-page-applications",permalink:"/id/docs/3.x/frontend/single-page-applications",draft:!1,unlisted:!1,editUrl:"https://github.com/FoalTS/foal/edit/master/docs/versioned_docs/version-3.x/frontend/single-page-applications.md",tags:[],version:"3.x",frontMatter:{title:"Single Page Applications (SPA)",sidebar_label:"Single Page Applications"},sidebar:"someSidebar",previous:{title:"Groups & Permissions",permalink:"/id/docs/3.x/authorization/groups-and-permissions"},next:{title:"Angular, React & Vue",permalink:"/id/docs/3.x/frontend/angular-react-vue"}},l={},c=[{value:"Building the App &amp; Proxifying Requests",id:"building-the-app--proxifying-requests",level:2},{value:"Using Frontend Routers",id:"using-frontend-routers",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Single-Page Applications are Web Applications that are loaded once upon the first request(s) to the backend. After retreiving all the necessary code from the server, the current page is rendered and updated directly in the browser without asking the server to render new pages. During its lifecycle, the application usually communicates with the server by making API calls to fetch, create, update or delete data. This is a common pattern used when creating a new application with Angular, React or Vue."}),"\n",(0,r.jsx)(t.p,{children:"Building a SPA, however, introduces a certain complexity. This document presents some techniques and tools for solving common scenarios."}),"\n",(0,r.jsx)(t.h2,{id:"building-the-app--proxifying-requests",children:"Building the App & Proxifying Requests"}),"\n",(0,r.jsxs)(t.p,{children:["See the ",(0,r.jsx)(t.a,{href:"/id/docs/3.x/frontend/angular-react-vue",children:"Angular, React & Vue"})," section to learn on how to configure your frontend CLI to interact with a Foal application."]}),"\n",(0,r.jsx)(t.h2,{id:"using-frontend-routers",children:"Using Frontend Routers"}),"\n",(0,r.jsxs)(t.p,{children:["Most single-page applications simulate routing on the frontend side. This is usually done by libraries such as ",(0,r.jsx)(t.a,{href:"https://reactrouter.com",children:"react-router"})," or ",(0,r.jsx)(t.a,{href:"https://angular.io/guide/router",children:"@angular/router"}),". The application does not actually make any requests to the server but simply modifies the URL in the address bar."]}),"\n",(0,r.jsx)(t.p,{children:"This works fine until the user presses the refresh button, shares the link or saves the page in their bookmarks. In that case, the browser makes a request to the server to retreive the desired page and thus gets a 404 error."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Example"})}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Request"}),(0,r.jsx)(t.th,{children:"Response"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"/"})}),(0,r.jsxs)(t.td,{children:["200 - Returns the ",(0,r.jsx)(t.code,{children:"index.html"})," file in the ",(0,r.jsx)(t.code,{children:"public/"})," directory."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"/users?city=Paris"})}),(0,r.jsxs)(t.td,{children:["404 - The server has no route that handles ",(0,r.jsx)(t.code,{children:"/users"}),"."]})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["One technique to solve this problem is to add a handler responsible for processing uncaught requests. It returns the ",(0,r.jsx)(t.code,{children:"index.html"})," page in all cases. This way, the browser loads the application which then looks at the address bar and displays the appropriate page."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context, controller, Get, HttpResponseNotFound, render } from '@foal/core';\n\nimport { ApiController } from './controllers';\n\nexport class AppController {\n  subControllers = [\n    controller('/api', ApiController),\n    // ...\n  ];\n\n  @Get('*')\n  renderApp(ctx: Context) {\n    if (!ctx.request.accepts('html')) {\n      return new HttpResponseNotFound();\n    }\n\n    return render('./templates/index.html');\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Note:"})," With this approach, the frontend is responsible for catching incorrect URLs and displaying a 404 page."]}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Note 2:"})," This issue usually does not show up in development as frontend CLIs are sufficiently clever to handle these requests."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(96540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);